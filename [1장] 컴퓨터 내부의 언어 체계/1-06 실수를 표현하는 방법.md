# 실수를 표현하는 방법

> ### 고정소수점 표현
  2진수를 사용해 소수를 표현하기 위해 2진 소수점의 위치를 임의로 정한다.
  그 위치를 일정하게 고정하는 방법이 고정소수점 표현이다
  쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트 개수가 너무 많기 때문에 범용 컴퓨터에서 이런 방식을 사용하는 경우는 드뭄 

  (단, 디지털 신호 처리 장치 등 특별한 목적에 쓰이는 컴퓨터는 일부 사용)

  플랑크 상수(양자 역학 기본 상수 중 하나)는 6.63 * 10^34J/s(초당 줄)라는 아주 작은 값이지만, 아보가드로 수(Avogadro's constant)는 6.02 * 10^23/몰 이라는 아주 큰 수다. 두 수의 범위는 10^57에 달하며, 대략 2^191 정도 된다. 거의 200비트가 필요하다. 모든 수를 몇백 비트로 표현하면 메모리 비용이 너무 많이 든다는 단점이 존재한다.

  ex) 고정소수점표현 예시
  7.625라는 수를 2진수로 표현하면 111.101이고, 이것을 16비트 체계에선 아래와 같이 저장하며,
  남는 공간은 0으로 다 채운다.
  
  ![고정소수점표현](https://user-images.githubusercontent.com/91880235/167648605-a9f033c0-7e4d-429b-aba6-e0bc31936e5e.png)
  

> ### 부동소수점 표현법  
  플랑크 상수부터 아보가드로 수에 이르는 범위의 값을 2진수로 표현하기 위해 과학적 표기법을 도입하여 큰 범위의 수를 표현함.
  예를 들어 0.0012라는 실수를 1.2 * 10^-3이라고 쓰고, 이런 표현법을 부동소수점으로 부른다. 
  하지만 부동소수점도 아래와 같이 비효율적인 부분이 존재한다.
  
  (4비트 예시 기준)

  **1. 비트 조합 중에 낭비되는 부분이 많다. 0을 표현하는 방법이 네 가지나 되고 1.0, 2.0, 4.0을 표현하는 방법도 2가지씩 존재**

  **2. 비트 패턴이 가능한 모든 수를 표현하지는 못한다. 지수가 커질수록 가수의 한 패턴과 다른 패턴 사이의 값 차이가 커진다.**
<br>

> ### IEEE 부동소수점 수 표준
이상하지만 부동소수점 수 시스템은 컴퓨터에서 계산을 수행할 때 실수를 표현하는 표준 방법이다. 그래서 낭비되는 비트 조합을 최소화하고 반올림을 쉽게 하기 위한 여러가지 트릭이 사용된다. IEEE 754라는 표준은 이 모든 기능을 정의한다. IEEE는 미국 전자전기공학회의 약자(Insitute Of Electrical and Electronics Engineers)로 표준 제정 등 다양한 활동을 하는 전문가 조직이다.
<br>

부동소수점은 두 가지 방법이 자주 쓰인다.

첫번 째는 **기본정밀도 부동소수점 수** (float)

두번 째는 **2배 정밀도 부동소수점 수** (double)

두 형태 모두 가수에 대한 부호를 사용한다. 하지만 지수에 대해 부호 비트가 따로 존재하지 않는다. IEEE 754 설계자들은 편향된 지숫값(bias)인을 사용하여 비트 패턴을 활용했다. 기본 정밀도의 경우 편향값은 127이며, 2배 정밀도 수는 편향값을 1023을 사용한다.


IEEE 754에서 편리한 점은 0으로 나눴을 때 생길 수 있는 양의 무한대나 음의 무한대를 표현하는 비트 패턴 등 여러 가지 특별한 비트 패턴을 제공한다. 'NaN'을 표현하는 특별한 값도 존재한다.

똑같은 비트를 사용하더라도 정밀도(precision)를 가능한 한 높이고 싶다면 한 가지 트릭은 정규화(nomalization) 정규화는 가수를 조정해서 맨 앞(즉, 왼쪽)에 0이 없게 만드는 것이다. 이런 식으로 가수를 조정하려면 지수도 조정해야한다. 두번 째 트릭은 디지털 이큅먼트 사(DEC, Digital Equipment Corporation)에서 고안한 것으로, 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로,이를 생략하는 것이다. 이로 인해 가수에 1비트를 더 사용할 수 있다.

> **정규화란?**
<hr>
2진수를 1.xxxx * 2^n 꼴로 변환하는 것이다.
예를 들면, 111.101을 1.11101 * 2^2로 변환하는 것
즉, 지수 부분을 1자리 수만 남기고 n만큼 이동시킨다.
그래서 소수점 부분이 옮겨가기에 부동소수점이라 불리는 것이 아닌가 싶다.

정규화를 할 때에 정수 부분에 1만 남겨두는 이유는 이진수에서 가장 앞자리는 항상 1이 되기 때문에 이를 빼고 바로 바로 뒤에 오는 수부터 23 비트를 채우게 되면 결과적으로 24 비트만큼 채우는 효과를 가져오기 때문이다.

<br>

> **편향값 활용**
<hr>
기본정밀도(32비트)는 아래와 같이 표현된다.

![image](https://user-images.githubusercontent.com/91880235/167650897-cfd17323-6061-4a16-aaeb-4416773742b8.png)

부호 비트는 고정소수점에서와 마찬가지로 0이면 양수, 1이면 음수를 의미한다.

23자리 가수부는 정규화 결과 소수점 오른쪽에 있는 숫자들을 왼쪽부터 그대로 넣으면 된다. 남는 자리는 0으로 채운다.

(참고: 소수점 왼쪽은 정규화를 하면 무조건 1이기 때문에 신경쓰지 않고 표현도 안 하는데, 이 1을 hidden bit라고 부르기도 한다)



남은건 8자리짜리 지수부인데, 일단 '지수' 부라는 이름으로 봤을 땐 2^n에서 n에 해당하는 수, 그러니까 예시에서는 2를 2진수로 바꾼 '10' 을 넣으면 될 것 같다.

근데 IEEE 표준에 따르면 저 부분에는 지수를 그대로 박아넣는게 아니라, 'bias' 라고 하는 지정된 숫자를 더한 다음 넣어야 한다.



IEEE 표준에서 32비트를 쓰는 경우 bias는 127이라고 규정하고 있다. 따라서 2 + 127 = 129를 2진수로 바꾼 10000001이 들어간다.

결론적으로 7.625는 컴퓨터에서 아래와 같이 저장된다.

![image](https://user-images.githubusercontent.com/91880235/167650447-c5bb2c8b-6cdb-43d6-9cfd-929158d2071f.png)

이 bias라는 값을 왜 쓰냐면, 지수가 음수가 될 수도 있어서 그렇다.

예를 들면 0.000101이라는 이진수가 있다 치자. 정규화에 대해서 설명할 때 정수부를 1로 만들어야 한다고 했다. 그러니까 왼쪽이 아니라 오른쪽으로 소수점을 밀어서 1.01 * 2^-4가 된다.

만약에 bias가 없어서 위에서 2를 그냥 00000010으로 저장했다고 생각해보자. -4는 어떻게 저장할래?

부호 비트는 지수의 부호를 뜻하는게 아니라 전체 숫자의 부호를 뜻하는 거라서 이거랑 상관이 없다.

그렇다고 지수용 부호 비트를 하나 더 만들자니 이것대로 복잡하다. 그래서 8자리를 가지고 음수랑 양수를 둘 다 표현하자니, (10진수 기준으로) 0~127 구간은 음수, 128~255 구간은 양수를 표현하도록 만든 것이다.

double, 그러니까 64비트 체계에서는 지수부가 11비트, 가수부가 52비트다. 지수부가 2^11 즉 2048개의 수를 표현할 수 있으므로 0~1023 구간은 음수, 1024~2047 구간은 양수 지수를 의미하며 bias는 1023이 된다.



이와 같은 부동소수점 표현 방식은 위에서 살펴본 고정소수점 표현 방식에 비해서 비트 수 대비 표현 가능한 수의 범위와 정밀도 측면에서 보다 우위에 있기 때문에, 정규화니 bias니 하는 복잡한 과정이 들어감에도 불구하고 현재 대부분의 컴퓨터 시스템에서 부동소수점을 이용해 실수를 표현하고 있다.

### <예시 자료>
![image](https://user-images.githubusercontent.com/91880235/167653531-700475e1-4328-4340-81e5-b7b043455696.png)

![image](https://user-images.githubusercontent.com/91880235/167653565-190fb2fd-0135-43ce-bc6e-0a770038567e.png)





# Reference
- [컴퓨터에서의 실수 표현: 고정소수점 vs 부동소수점](https://gsmesie692.tistory.com/94)
- [부동소수점 방식 표현](https://codetorial.net/articles/floating_point.html)
- [[ 컴퓨터 구조 기초 ] IEEE 754 표준 Interchange Formats와 정규화(Normalize)](https://blog.naver.com/r00tdr4g0n/222009363042)
- [[컴퓨터과학/C언어] IEEE 754 double 형 변환 (64bit)](https://backstreet-programmer.tistory.com/140)