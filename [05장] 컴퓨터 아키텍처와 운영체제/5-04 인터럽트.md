### 인터럽트

<br/>
<p align="center">
<img width="700" alt="스크린샷 2022-06-12 오전 11 53 41" src="https://user-images.githubusercontent.com/80025242/173212475-7ab71b8d-78f1-4d9c-89a0-d785fe347f15.png">
</p>
<br/>

- 첫 번째 방법의 문제점   
  쿠키를 다 만들기 전까지는 소포를 받아볼 수 없다.

<br/>

- 두 번째 방법의 문제점   
  쿠키를 만드는 모든 단계마다 소포가 왔는지 안 왔는지 확인하는 시스템. (`polling` 이라고 부름)   
  소포를 못 받을 가능성은 줄어들지만, 문 앞에 누가 왔는지 검사하는데 너무 많은 시간을 소모하게 된다.
  
<br/>

- 결론   
  소프트웨어적으로 이 문제를 해결할 수 있는 방법은 없다.   
  때문에, 실행 중인 프로그램을 잠깐 중단(`interrupt`)시키고 외부의 요소에 대응할 수 있게 하는 방법이 존재한다.   
  <br/>
  ```
  우선적으로 처리해야하는 태스크가 있어서 프로그램의 실행을 잠깐 중단하는 것을 '인터럽트한다' 라고 표현.
  ```
  
<br/>

### 인터럽트 시스템

<br/>

요즘 쓰이는 프로세서 대부분은 인터럽트(`interrupt`) 시스템이 들어간다.   
인터럽트 시스템은 적절한 신호가 들어오면 CPU 실행을 잠깐 중단할 수 있는 `핀`이나 `전기 연결`을 포함한다.


<br/>

### 인터럽트 시스템 동작 원리

<br/>

```
1. 인터럽트 요청 신호 발생
2. 프로그램 실행 중단 : 보통은 현재 실행중인 명령까지는 끝까지 수행함
3. 현재 프로그램 상태 보존 : PC는 항상 다음번 실행할 명령의 주소를 가지고 있음
4. 인터럽트 처리 루틴 실행 : 인터럽트 백터를 보고 (인터럽트가 발생한) 장치 식별
5. 인터럽트 취급(서비스) 루틴 실행 (실질적인 인터럽트 처리)
6. 상태 복구
7. 중단된 프로그램 실행
```

<br/>

`4`,`5`번이 `인터럽트 핸들러`에 해당하는 작업이다.

<br/>

- 인터럽트 시스템은 서비스 후 돌아올 프로그램의 위치를 어디에 저장하는가 ?   
  `Stack`에 저장한다. 인터럽트 핸들러는 자신이 덮어쓸 레지스터를 모두 저장해야 할 책임이 있다.

<br/>

- 컴퓨터는 어떻게 `인터럽트 핸들러`의 위치를 찾는가 ?   
  보통은 인터럽트 핸들러의 주소를 저장하기로 약속한 메모리 주소가 존재한다.   
  이 주소에 여러 `인터럽트 백터`가 들어있고, 인터럽트 백터는 CPU가 지원하는 각 인터럽트에 대한 핸들러 주소를 저장한다.   
  `인터럽트 백터`는 메모리를 가리키는 `포인터`이다.
